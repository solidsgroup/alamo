#ifndef MODEL_SOLID_FINITE_ADHESION_H_
#define MODEL_SOLID_FINITE_ADHESION_H_

#include "IO/ParmParse.H"
#include "Model/Solid/Solid.H"
#include <cmath> // For std::pow and std::exp
#include </usr/include/eigen3/Eigen/Dense> // For Eigen::Matrix3d
#include <array> // For std::array to represent fourth-order tensors
#include "Set/Set.H"

namespace Set {

// Outer product for two 3x3 matrices producing a 3x3x3x3 tensor
inline std::array<std::array<std::array<std::array<double, 3>, 3>, 3>, 3> 
Outer(const Eigen::Matrix3d& A, const Eigen::Matrix3d& B) {
    std::array<std::array<std::array<std::array<double, 3>, 3>, 3>, 3> result = {};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            for (int k = 0; k < 3; ++k)
                for (int l = 0; l < 3; ++l)
                    result[i][j][k][l] = A(i, j) * B(k, l);
    return result;
}

// Derivative of inverse transpose: d(F^-T) / dF
inline std::array<std::array<std::array<std::array<double, 3>, 3>, 3>, 3> 
Derivative(const Eigen::Matrix3d& FinvT) {
    std::array<std::array<std::array<std::array<double, 3>, 3>, 3>, 3> result = {};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            for (int k = 0; k < 3; ++k)
                for (int l = 0; l < 3; ++l)
                    result[i][j][k][l] = -FinvT(i, j) * FinvT(k, l);
    return result;
}

} // namespace Set

namespace Model {
namespace Solid {
namespace Finite {

class Adhesion : public Solid<Set::Sym::Major> {
public:
    Adhesion() {};
    Adhesion(Solid<Set::Sym::Major> base) : Solid<Set::Sym::Major>(base) {};
    virtual ~Adhesion() {};

    // Static methods for Zero and Random initialization
    static Adhesion Zero() {
        Adhesion adhesion;
        adhesion.d = 1;      // Default value for d
        adhesion.mu = 1;     // Default value for mu
        adhesion.K = 10;     // Default value for K (formerly kappa)
        adhesion.xi = 0.1;   // Default value for xi (formerly zeta)
        adhesion.n = 2;      // Default value for n
        return adhesion;
    }

    static Adhesion Random() {
        Adhesion adhesion;
        adhesion.d = static_cast<Set::Scalar>(std::rand()) / RAND_MAX + 1;  // Random value near 1
        adhesion.mu = static_cast<Set::Scalar>(std::rand()) / RAND_MAX + 1;
        adhesion.K = static_cast<Set::Scalar>(std::rand()) / RAND_MAX * 10; // Random value up to 10
        adhesion.xi = static_cast<Set::Scalar>(std::rand()) / RAND_MAX * 0.1; // Random value up to 0.1
        adhesion.n = 2;  // Keep n constant for simplicity
        return adhesion;
    }

    // Potential Energy Function W(F)
    Set::Scalar W(const Set::Matrix& a_F) const override {
        Eigen::Matrix3d F = a_F;
        Set::Scalar J = F.determinant();
        Set::Scalar J23 = std::pow(std::fabs(J), 2.0 / 3.0);
        Set::Scalar w = 0.0;

        w += d * (0.5 * mu * ((F * F.transpose()).trace() - 3.0) / J23 
                  + 0.5 * K * (J - 1.0) * (J - 1.0));
        w += xi / std::pow(J, n);

        return w;
    }

    // First Derivative: DW(F)
    Set::Matrix DW(const Set::Matrix& a_F) const override {
        Eigen::Matrix3d F = a_F;
        Set::Scalar J = F.determinant();
        Set::Scalar J23 = std::pow(std::fabs(J), 2.0 / 3.0);
        Set::Scalar J53 = std::pow(std::fabs(J), 5.0 / 3.0);
        Eigen::Matrix3d FinvT = F.inverse().transpose();

        Eigen::Matrix3d dw = d * mu * (2.0 * F / J23 
                          - (2.0 / 3.0) * ((F * F.transpose()).trace() - 3.0) * J * FinvT / J53)
                          + d * K * (J - 1.0) * J * FinvT
                          - xi * n * std::pow(J, -n) * FinvT;

        return dw;
    }

    // Second Derivative: DDW(F)
    Set::Matrix4<AMREX_SPACEDIM, Set::Sym::Major> DDW(const Set::Matrix& a_F) const override {
        Eigen::Matrix3d F = a_F;
        Set::Scalar J = F.determinant();
        Set::Scalar J23 = std::pow(std::fabs(J), 2.0 / 3.0);
        Set::Scalar J53 = std::pow(std::fabs(J), 5.0 / 3.0);
        Set::Scalar J83 = std::pow(std::fabs(J), 8.0 / 3.0);
        Eigen::Matrix3d FinvT = F.inverse().transpose();

        Set::Matrix4<AMREX_SPACEDIM, Set::Sym::Major> ddw;

        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                for (int k = 0; k < 3; ++k) {
                    for (int l = 0; l < 3; ++l) {
                        ddw(i, j, k, l) = d * mu * (
                            2.0 * (i == k && j == l) / J23 
                            - (4.0 / 3.0) * (F(i, k) * J * FinvT(j, l)) / J53 
                            - (2.0 / 3.0) * (2.0 * F(i, k) * FinvT(j, l) - (F * F.transpose()).trace() * FinvT(i, k) * FinvT(j, l)) / J53 
                            + (10.0 / 9.0) * FinvT(i, k) * FinvT(j, l) / J83
                        )
                        + d * K * (J * FinvT(i, k) * J * FinvT(j, l) + (J - 1.0) * Set::Derivative(FinvT)(i, j, k, l))
                        + xi * n * (n * std::pow(J, -n - 1) * FinvT(i, k) * FinvT(j, l) - std::pow(J, -n) * Set::Derivative(FinvT)(i, j, k, l));
                    }
                }
            }
        }

        return ddw;
    }

    virtual void Print(std::ostream& out) const override {
        out << "d = " << d << ", mu = " << mu 
            << ", K = " << K << ", xi = " << xi 
            << ", n = " << n;
    }

public:
    Set::Scalar d = 1;      // Default value for d
    Set::Scalar mu = 1;     // Default value for mu
    Set::Scalar K = 10;     // Default value for K (formerly kappa)
    Set::Scalar xi = 0.1;   // Default value for xi (formerly zeta)
    Set::Scalar n = 2;      // Default value for n
};

} // namespace Finite
} // namespace Solid
} // namespace Model

#endiff



gggg
gg
tt





