#!/usr/bin/python
import os 
import re
from os import listdir
from os.path import isfile, join
from glob import glob
import sys
sys.path.insert(0,"../../scripts")

import scraper
from scraper import getdocumentation, geticon, extract

src2url = {}
try:
	doxsourcefiles = sorted(glob("../build/html/doxygen/*source.html"))
	for doxsourcefile in doxsourcefiles:
	    with open(doxsourcefile) as f:
	        for line in f.readlines():
	            if r"<title>" in line:
	                line = line.replace(r"<title>Alamo: ","")
	                line = line.replace(r" Source File</title>","")
	                line = line.replace("\n","")
	                src2url[line] = doxsourcefile.replace("../build/html/","")
	                continue
except Exception as e:
    print(e)

inputsheader = r"""
.. _inputs: 
	
=============================
:fas:`cube;fa-fw` Inputs
=============================
	
"""


inputsearchheader = r"""
.. _inputssearch: 

===========================================
:fas:`magnifying-glass;fa-fw` Inputs Search
===========================================

Use the following box to search over all alamo inputs and descriptions.
This is the same list as in the :ref:`Inputs` section as generated by the autodoc system.

:bdg-primary-line:`Note` If searching for documentation on an alamo command that you found
in an input file, remember that the prefix may not be included in this table. For instance,
if you are looking for documentation on the following inputs

.. code-block:: bash

    hc.heat.alpha = 1.0
    el.nmodels = 2

the prefixes :code:`hc` and :code:`el` are not necessarily included, and you will not find them
if you do an exact search.
Instead, do a reverse search, starting with :code:`alpha` and :code:`nmodels`, then work out 
the prefixes out.


.. raw:: html

    <div class="input-group mb-3">
      <div class="input-group-prepend">
        <span class="input-group-text" id="inputGroup-sizing-default">
            <span class="fas fa-magnifying-glass fa-fw"></span>
        </span>
      </div>
      <input id='myInput' onkeyup='searchTable()' type="text" class="form-control" aria-label="Default" aria-describedby="inputGroup-sizing-default">
    </div>

    <!--input id='myInput' onkeyup='searchTable()' type='text'-->

    <script>
    function searchTable() {
        var input, filter, found, table, tr, td, i, j;
        input = document.getElementById("myInput");
        filter = input.value.toUpperCase();
        table = document.getElementsByClassName("api-inputs-table")[0];
        body = table.getElementsByTagName("tbody")[0];
        tr = body.getElementsByTagName("tr");
        for (i = 0; i < tr.length; i++) {
            td = tr[i].getElementsByTagName("td");
            for (j = 0; j < td.length; j++) {
                if (td[j].innerHTML.toUpperCase().indexOf(filter) > -1) {
                    found = true;
                }
            }
            if (found) {
                tr[i].style.display = "";
                found = false;
            } else {
                tr[i].style.display = "none";
            }
        }
    }
    </script>

    <style>
    table.api-inputs-table thead tr th:nth-child(1)
    {
        width:30%!important;
    }
    </style>


.. raw:: html

   <table class="api-inputs-table docutils align-default">
     <thead><tr>
       <th class="head"><p>Parameter</p></th>
       <th class="head"><p>Type</p></th>
       <th class="head"><p>Values</p></th>
     </tr></thead>
     <tbody>
"""


def printAPI(docfile, file, api):

    def clean(rec):
        ret = ""
        if rec['brief_description']:
            if (isinstance(rec['brief_description']['para'],dict)):
                ret += "- "+ str(rec['brief_description']['para']['#text'])
            else:
                ret += "- "+ str(rec['brief_description']['para'])
        return ret

    docfile.write(".. dropdown:: API definitions in {}\n".format(file))
    docfile.write("\n")
    docfile.write(   "    **Classes**\n\n")
    
    for cls in api["classes"]:
        if cls["file"]  != file: continue

        docfile.write(        "    - :code:`{}`\n".format(cls['name']))
        docfile.write(        "      {}          \n".format(clean(cls)))

        if cls["methods"]:
            docfile.write(    "      \n")
            docfile.write(    "      **Methods**\n\n")
            for method in cls["methods"]:
                docfile.write("      - :code:`{}`\n".format(method['name']+method['argsstring']))
                docfile.write("        {}\n".format(clean(method)))

        if cls["variables"]:
            docfile.write(    "      \n")
            docfile.write(    "      **Variables**\n\n")
            for var in cls["variables"]:
                docfile.write("      - :code:`{}`\n".format(var['definition']))
                docfile.write("        {}\n".format(clean(var)))

    written_methods_yet = False;
    for method in api["methods"]:
        if cls["file"]  != file: continue

        if not written_methods_yet:
            docfile.write(    "    **Methods**\n\n")
            written_methods_yet = True
        
        docfile.write(        "   - :code:`{}`\n".format(method['name']+method['argsstring']))
        docfile.write(        "     {}\n".format(clean(method)))




def write(root="../../src/"):

    docs = scraper.scrape(root)

    from doxscrape import parse_all_doxygen_files
    api = parse_all_doxygen_files("../build/html/doxygen/doxygen_xml/")
    
    docfilesearch  = open("InputsSearch.rst","w")
    docfilesearch.write(inputsearchheader)
    
    docfile = open("Inputs.rst","w")
    docfile.write(inputsheader)
    
    headerchar = ["=","*","-","~","."]
    written_headers = []
    
    global num_tot, num_doc
    num_tot = 0
    num_doc = 0

    for classname in docs:
        inputs = docs[classname]['inputs']
        documentation = docs[classname]['documentation']
    
        subhdr = ""
        for i in range(len(classname.split('::'))):
            subhdr = '::'.join(classname.split('::')[:i])
            if subhdr not in written_headers:
                if '::' not in subhdr and subhdr != "":
                    docfile.write("--------------------\n\n\n")
                    docfile.write(".. _{}:\n\n".format(subhdr))
                    docfile.write(geticon(subhdr) + subhdr+"\n")
                    docfile.write("".ljust(len(geticon(subhdr)+subhdr),headerchar[i-1]))
                else:
	                docfile.write("\n" + subhdr+"\n")
	                docfile.write("".ljust(len(subhdr),headerchar[i-1]))
                docfile.write("\n\n\n")
            written_headers.append(subhdr)
    
        docfile.write(classname + "\n")
        lev = len(classname.split('::'))-1
        docfile.write("".ljust(len(classname),headerchar[lev])+"\n\n")
        subhdr = classname
                
        srcfile = docs[classname]['srcfile']
        hdrfile = docs[classname]['hdrfile']
        if srcfile or hdrfile:
            docfile.write("\n\n")
            if srcfile:
                docfile.write(r":bdg-link-primary-line:`{} <{}>`".format(srcfile,src2url[srcfile])+"\n")
            if hdrfile:
                docfile.write(r":bdg-link-secondary-line:`{} <{}>`".format(hdrfile,src2url[hdrfile])+"\n")
            docfile.write("\n\n")

        if documentation:
            docfile.write(documentation)
                
        if not len(inputs):
            printAPI(docfile,hdrfile,api)
            continue
        if len(inputs) == 1 and not list(inputs)[0]:
            printAPI(docfile,hdrfile,api)
            continue
    
        docfile.write("""\n\n""")
        docfile.write(""".. raw:: html \n\n""")
        docfile.write("""                 \n""")
        docfile.write("""   <table class="api-inputs-table docutils align-default">\n\n""")
        docfile.write("""     <thead><tr> \n""")
        docfile.write("""       <th class="head"><p>Parameter</p></th> \n""")
        docfile.write("""       <th class="head"><p>Type</p></th> \n""")
        docfile.write("""       <th class="head"><p>Values</p></th> \n""")
        docfile.write("""     </tr></thead> \n""")
        docfile.write("""     <tbody> \n""")

        def writeInput(input,lev,prefix):

            prefix = list(filter(lambda x: x != "", prefix))
            if (input["type"]=="group"):
                for subinput in input["inputs"]:
                    writeInput(subinput,lev+1,prefix + [input["prefix"]])
                    
            elif (input["type"] in ["query","queryarr","query_validate",
                                  "query_default","queryarr_default",
                                  "query_required","queryarr_required",
                                  "query_file", "select", "select_default"]):

                input_html_row = """      <tr> \n"""

                global num_tot, num_doc
                #if input["parsefn"]: prefix = ["[prefix]"] + prefix
                num_tot += 1

                # update the selects to derive the "type" that they should be
                # and set the name to "type"
                if input["type"] in ["select","select_default"]:
                    input['possibles'] = [str(cl).split('::')[-1].lower() for cl in input["classes"]]
                    input["string"] += ".type"

                codetarget = ""
                try:
                    filename = src2url[input["file"].replace("../../","")]
                    linenumber = "l"+str(input["line"]).zfill(5)
                    codetarget = filename+"#"+linenumber
                except Exception as e:
                    print(e)

                bdg_secondary_ext = "sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary reference external"
                fullname = '.'.join(prefix+[input['string']])

                input_html_row += f"""         <td><p><a href="{codetarget}" class="{bdg_secondary_ext}"> """
                input_html_row += f"""                 <span>{fullname}</span></a></p>""" 
                input_html_row += f"""         </td> \n"""


                bdg_success   = "sd-sphinx-override sd-badge sd-outline-success sd-text-success"
                bdg_primary   = "sd-sphinx-override sd-badge sd-outline-primary sd-text-primary"
                bdg_secondary = "sd-sphinx-override sd-badge sd-outline-secondary sd-text-secondary"
                bdg_danger    = "sd-sphinx-override sd-badge sd-outline-danger sd-text-danger"
                if input["doc"] != "":
                    value_string = ""
                    if input["type"] in ["query_default","queryarr_default"]:
                        value_string += f"""<span class="{bdg_success}">{input['default']}</span>"""
                    if "_required" in input["type"]:
                        value_string += f"""<span class="{bdg_danger}">required</span>"""
                    if "_file" in input["type"]:
                        value_string += f"""<span class="{bdg_secondary}">file path</span> """
                    if "_validate" in input["type"]:
                        things = [d.replace('"',"").replace("'","").strip() for d in input['possibles'].split(',')]
                        value_string = f"""<span class="{bdg_success}">{things[0]}</span> """
                        value_string += " ".join([f"""<span class="{bdg_primary}">{thing}</span>""" for thing in things[1:]])
                    if input["type"] in ["select","select_default"]:
                        things = input['possibles']
                        if input["type"] == "select_default":
                            value_string = f"""<span class="{bdg_success}">{things[0]}</span> """
                            value_string += " ".join([f"""<span class="{bdg_primary}">{thing}</span>""" for thing in things[1:]])
                        elif input["type"] == "select":
                            value_string = " ".join([f"""<span class="{bdg_primary}">{thing}</span>""" for thing in things])

                    # Convert RST math directeves to plain mathjax
                    processed_doc = re.sub(r":math:`(.*?)`", r"\\(\1\\)", input['doc'].replace('\n',''))
                    # Convert RST code directives to <code>
                    processed_doc = re.sub(r":code:`(.*?)`", r"<code>\1</code>", processed_doc)
                    

                    if value_string != "": 
                        input_html_row += f"""         <td colspan="1"><p><span>{processed_doc}</span></p></td> \n"""
                        input_html_row += f"""         <td><p>{value_string}</p></td> \n"""
                    else:
                        input_html_row += f"""         <td colspan="2"><p><span>{processed_doc}</span></p></td> \n"""


                    docfile.write(input_html_row)
                    docfilesearch.write(input_html_row)
                    num_doc +=1


                else:
                    print(input)
                    print(input['file'],':',input['line'],' ',input['string'],' missing documentation')
                    docfile.write("      - \n")
                    docfilesearch.write("      - \n")
    
            docfile.write("\n")
            docfilesearch.write("\n")

        for input in inputs:
            writeInput(input,0,[])
            
        docfile.write("""     </tbody> \n""")
        docfile.write("""   </table>\n\n""")


        printAPI(docfile,hdrfile,api)
        docfile.write("\n")
        docfilesearch.write("\n")

    
    print("\n{} of {} inputs documented\n".format(num_doc,num_tot))
    


    docfilesearch.write("""     </tbody> \n""")
    docfilesearch.write("""   </table>\n\n""")
    
    docfile.close()
    docfilesearch.close()

    return num_doc, num_tot


write()
